# Application Investigation Details

## **Application metadata**
> Application Name: Camera app
> package name: com.
> version code: 12
> version name: 1.2.8
> Hash: 72b4a77cd28f4fcd344cb5fb6888b5db

## **Classification**
Based on the data in **Analysis** section, the app can be considered as __Toll Fraud__

#### **Description: Toll Fraud**
Code that tricks users into subscribing to or purchasing content via their mobile phone bill. Toll Fraud includes any type of billing except premium SMS and premium calls.  
Examples of this include direct carrier billing, wireless access point (WAP), and mobile airtime transfer. WAP fraud is one of the most prevalent types of Toll fraud. WAP fraud can include tricking users to click a button on a silently loaded, transparent WebView. Upon performing the action, a recurring subscription is initiated, and the confirmation SMS or email is often hijacked to prevent users from noticing the financial transaction.

For the app to execute __toll fraud__ functionality, the phone should be in cellular data mode and the app should have the permission (`RECEIVE_SMS` or `BIND_NOTIFICATION_LISTENER`) to read the OTP during WAP subscription

## **Analysis**
This section contains a thorough analysis of the target application. A mixture of static and dynamic analysis techniques has been performed in order to investigate the application's behavior and conclude the application as malicious.

The application is analyzed using __apktool__ and __jadx__.

### **Architecture**
The application is developed using __Java__. And the main part of the code is found under `com.wevedarkrig` after decompiling it.

The application also has native libraries for `armeabi-v7a` and `arm64-v8`, and libraries are:
- `libimg_ps.so`
- `libNativeImageProcessor.so`
- `libpanorenderer.so`
- `libpano_video_renderer.so`
- `libpl_droidsonroids_gif.so`
- `librsjni_androidx.so`
- `librsjni.so`
- `libRSSupport.so`
- `libyuv-decoder.so`

### **Permissions and Capabilities**
As specified in `AndroidManifest.xml`, the application has dangerous [permissions](./screenshots/permissions.png) and components to perform the malicious activity

#### **Permissions**
- `android.permission.ACCESS_NETWORK_STATE`
- `android.permission.ACCESS_WIFI_STATE`
- `android.permission.CAMERA`
- `android.permission.CHANGE_WIFI_STATE`
- `android.permission.INTERNET`
- `android.permission.READ_EXTERNAL_STORAGE`
- `android.permission.RECORD_AUDIO`
- `android.permission.SET_WALLPAPER`
- `android.permission.USE_FINGERPRINT`
- `android.permission.VIBRATE`
- `android.permission.WAKE_LOCK`
- `android.permission.WRITE_EXTERNAL_STORAGE`
- `com.google.android.c2dm.permission.RECEIVE`

#### **Capabilities**
- `android.permission.BIND_NOTIFICATION_LISTENER_SERVICE` - class: `com.wevedarkrig.radersten.pro.vertyl.NationService`

For __toll fraud__ to execute the application simply requires `INTERNET` permission, but this app has
- `android.permission.CHANGE_WIFI_STATE` -  for changing the device to cellular data
- `android.permission.BIND_NOTIFICATION_LISTENER_SERVICE` - for reading the otp send to the device from notifications.

### **Static Analysis**

#### **Application Entry points**

- `com.wevedarkrig.radersten.pro.App`- **application subclass**
- `com.wevedarkrig.radersten.pro.activities.CameraMainActivity` - **launcher activity**
- `com.wevedarkrig.radersten.pro.vertyl.NationService` - **Bind notification listener service**

These are the relevant entry point classes.

##### **Application Subclass**
The application has a custom application class: `com.wevedarkrig.radersten.pro.App`, which extends `android.app.Application` and it is the code which will executed when the app starts. Initial configurations for the application are performed on this class

<p align="center">
    <img src="./screenshots/static/2.png" />
    <br/>
    <strong>Image 2.png:</strong> Declaration of application subclass in AndroidManifest.
</p>

On inspecting the class, it has code for initializing app configurations such as initializing `AdManager`, initializing `Firebase` classes etc.

- [onCreate](./screenshots/static/3.png)

##### **Launcher Activity**
The launcher activty: `com.wevedarkrig.radersten.pro.activities.CameraMainActivity` is the activity which will be executed and shown to the user when the user clicks on the icon of the application. The launcher activity is determined by activity's intent filter action `android.intent.action.MAIN` and category `android.intent.category.LAUNCHER` as we can see in image: __4.png__

<p align="center">
    <img src="./screenshots/static/4.png" />
    <br/>
    <strong>Image 4.png:</strong> Declaration of launcher activity in AndroidManifest.
</p>

The starting function, `onCreate` of the activity, initailizes a set of `TextView` widgets and intializes click listeners for the widgets, invokes a function **startlaunch()** and then checks for `CAMERA` permission and if the permission is enabled `CameraPreviewActivity` is started.

<p align="center">
    <img src="./screenshots/static/5.png" />
    <br/>
    <strong>Image 5.png:</strong> onCreate function.
</p>

###### **startlaunch()**
In this function, there is code to create instance of `deeplthy` and invokes **getFixer()** and then invokes **start()** function

<p align="center">
    <img src="./screenshots/static/6.png" />
    <br/>
    <strong>Image 6.png:</strong> startlaunch() function.
</p>

##### **com.wevedarkrig.radersten.pro.vertyl.deeplthy**
The class `deeplthy` is the core class of the application which initiates the malicious activity by loading a dex file which contains the malicious code. The function `getFixer()` initialises the class variables with the `.ttf` file in `assets/font` folder.

###### **getFixer()**
The function initialises the data members `FILE_PATH` with `fonts/` and `ASSETS_FILE` with `Zapfino 2.ttf` and also invokes `loadMap()`.  
The `loadMap()` initializes HashMap data member `nameMap` with values such as `loadClassNameString`-> `com.tlvreao.trlonameolp.klobleo`, `methodInstance`-> `getInstance`, `methodInit`-> `init` etc, which looks suspicious since the class name specified is not present in this app

<p align="center">
    <img src="./screenshots/static/7.png" />
    <br/>
    <strong>Image 7.png:</strong> getFixer() function in deeplthy class.
</p>


<p align="center">
    <img src="./screenshots/static/8.png" />
    <br/>
    <strong>Image 8.png:</strong> suspicious .ttf files in assests/font folder.
</p>

###### **start()**
`start()` function first executes `invokePatch()` function in an `if` condition. Based on the return value of the function, `loadDexFromAssets(ASSETS_FILE)` will be executed.

__invokePatch()__:  
The function first gets the `File` object from `prepareDex` data member and checks if the object is `null`. `prepareDex` is null initially, so the if condition becomes `false`.

Since the `invokePatch()` returns false, `loadDexFromAssests()` will be executed next.

<p align="center">
    <img src="./screenshots/static/9.png" />
    <br/>
    <strong>Image 9.png:</strong> start() function in deeplthy class.
</p>

###### **loadDexFromAssets()**
The function has single string argument which has `Zapfino 2.ttf` for this instance. In this function, at first `FileUtil.copyFileAndDecode` is invoked with
- first argument is the `context`
- second argument as `FILE_PATH` which has value `fonts/` from `image 6.png` and `image 7.png`
- third argument is a string which has value `Zapfino 2.ttf` from function argument
- fourth argument as 'sourcefile' which is set as `77872` in `image 7.png`
- fifth argument as `filecode` which is already set as `57` in `image 7.png`

<p align="center">
    <img src="./screenshots/static/10.png" />
    <br/>
    <strong>Image 10.png:</strong> loadDexFromAssets() function in deeplthy class.
</p>

If the file object returned by `FileUtil.copyFileAndDecode` is not `null`, then the function sets `prepareDex` as the file object and invokes **getLoaderResult()** with the file object, `copyFileAndDecode`

##### **com.wevedarkrig.radersten.pro.vertyl.FileUtil**

###### **copyFileAndDecode**
The function creates a dex file named `Zapfino 2.dex` in cache directory and copy all data in `assets/fonts/Zapfino 2.ttf` to the dex file. The dex file object is then passed to `FileUtil.decodeFile()` with
- first param as the `Zapfino 2.dex` file object
- second param is a the file path of a new file `1.dex` in cache directory
- third and fourth are the integer values passed to this function - `77872` and `57`

<p align="center">
    <img src="./screenshots/static/11.png" />
    <br/>
    <strong>Image 11.png:</strong> copyFileAndDecode() function in FileUtil class.
</p>

###### **decodeFile**
The [function](./screenshots/static/12.png) was unable to decompile by `jadx`. With the help of `smali` code and half decompiled code in `jadx`, a java copy of `decodeFile` is created in [decodeFile.java](./utils/decode/decodeFile.java). On executing the java code, the code was able to create the secondary dex file [1.dex](./utils/decode/1.dex).  

`decodeFile` function returns the file object of `1.dex` to **loadDexFromAssets()** where the file object is passed to **getLoaderResult()** in **com.wevedarkrig.radersten.pro.vertyl.deeplthy**

##### **com.wevedarkrig.radersten.pro.vertyl.deeplthy**

###### **getLoaderResult()**
The function loads the class in `nameMap['loadClassNameString'] -> com.tlvreao.trlonameolp.klobleo` from the `1.dex` file decoded. The function invokes `nameMap['methodInit'] -> init` in the same class

<p align="center">
    <img src="./screenshots/static/13.png" />
    <br/>
    <strong>Image 13.png:</strong> getLoaderResult() function.
</p>

On inspecting the `1.dex` file, there is a class with the `com.tlvreao.trlonameolp.klobleo` and the same class has the function called `init`.

##### **com.tlvreao.trlonameolp.klobleo**

<p align="center">
    <img src="./screenshots/static/14.png" />
    <br/>
    <strong>Image 14.png:</strong> com.tlvreao.trlonameolp.klobleo class.
</p>

###### **init()**
The function which does the initialization for the class, and it invokes `getDatafromServer` function in the end (check `image 14.png`).

###### **getDatafromServer()**
The function takes a string argument which is assigned with `GlobalConfig.APP_KEY` and the value is present in `GlobalConfig` which is a class which has configuration variables.
The function first contacts a url in variable `API_STATUS` present in `com.tlvreao.extra.common.constant.Location`. The url is `http://54.255.9.143/bvg/tsjTR`. Then the function will execute some code in the `onResponse` block.

<p align="center">
    <img src="./screenshots/static/15.png" />
    <br/>
    <strong>Image 15.png:</strong> getDatafromServer() func.
</p>

###### **com.tlvreao.extra.common.constant.GlobalConfig**
This class has suspicious keywords like `CLOSE_WIFI` and `NOTIFICATION_CLASSNAME` related to toll_fraud.

<p align="center">
    <img src="./screenshots/static/16.png" />
    <br/>
    <strong>Image 16.png:</strong> com.tlvreao.extra.common.constant.GlobalConfig class.
</p>

###### **com.tlvreao.extra.common.constant.Location**
Class which is used to store all the URLs related to the dex file.

<p align="center">
    <img src="./screenshots/static/17.png" />
    <br/>
    <strong>Image 17.png:</strong> com.tlvreao.extra.common.constant.Location class.
</p>

In **getDatafromServer()** function, in the end of `onResponse` block, `klobleo.getNotification()` is invoked (check in `image 15.png`).

###### **com.tlvreao.trlonameolp.klobleo.getNotification()**
This function sends SIM information to server to check for avaliability.
`getNotification()` ->  `realOpen()``

<p align="center">
    <img src="./screenshots/static/18.png" />
    <br/>
    <strong>Image 18.png:</strong> getNotification() function definition.
</p>

###### **com.tlvreao.trlonameolp.klobleo.realOpen()**
`realOpen()` -> `OrderControler.getInstance().init()`

<p align="center">
    <img src="./screenshots/static/19.png" />
    <br/>
    <strong>Image 19.png:</strong> realOpen() function definition.
</p>

##### **com.tlvreao.trlonameolp.OrderControler**

###### **init()**
`init()` -> `exciter()`

<p align="center">
    <img src="./screenshots/static/20.png" />
    <br/>
    <strong>Image 20.png:</strong> init() function & getInstance() function definitions.
</p>

###### **exciter()**
Checks if the device is in cellular data using API `isMobileData()`.    
If the device is in cellular data, then `exciter()` -> `acquireOffer()`  else then `exciter()` -> `closeWifi()`

<p align="center">
    <img src="./screenshots/static/21.png" />
    <br/>
    <strong>Image 21.png:</strong> exciter() function & closeWifi() function definitions.
</p>

###### **closeWifi()**
In this function, the app registers a receiver: `mWifiStateReceiver` for monitoring connectivity change `android.net.conn.CONNECTIVITY_CHANGE`. The receiver will disables `WIFI` if user enables it.

__mWifiStateReceiver__
<p align="center">
    <img src="./screenshots/static/22.png" />
    <br/>
    <strong>Image 22.png:</strong> mWifiStateReceiver definition.
</p>

###### **acquireOffer()**
In this function, the main implementation of __toll_fraud__ happens. The function subscribe for the offer using the __SIM's__ __mnc__ code to the url in `Location.API_PULL_OFFER` : `http://54.255.9.143/out/xbfTk`.

<p align="center">
    <img src="./screenshots/static/23.png" />
    <br/>
    <strong>Image 23.png:</strong> acquireOffer() function which has wap subcribing code.
</p>

From the details from the above analysis we can found that the `app disables wifi` and `subscribes an offer` by sending a network request.

For the app to subscibe the offer, i.e., to perform __toll_fraud__, the app has to upload the __OTP__ send to the device.

Inorder to receive the __OTP__, the app can use the `BIND_NOTIFICATION_LISTENER_SERVICE`: `com.wevedarkrig.radersten.pro.vertyl.NationService`

##### **com.wevedarkrig.radersten.pro.vertyl.NationService**
The service takes any notification and broadcast the notification with `com.brvelo.chtyp` as action. As a result, the app can send __OTP__ received also as the broadcast.

<p align="center">
    <img src="./screenshots/static/24.png" />
    <br/>
    <strong>Image 24.png:</strong> NationService class.
</p>
The speciality of the broadcast is that a receiver which is registered with `com.brvelo.chtyp` action can receive the notification object which contains __OTP__ and process it.     

On inspecting the classes in __DCL__ dex file `1.dex`, there is one class: `com.tlvreao.extra.Http.core.Hatchet` which registers a receiver: `mNotificationReceiver` for handling the same action.

<p align="center">
    <img src="./screenshots/static/25.png" />
    <br/>
    <strong>Image 25.png:</strong> Registering a receiver for handling the notifications send notification service.
</p>

###### **mNotificationReceiver**
The receiver invokes `onReceiveSms()` function and the received message is passed to the function.

<p align="center">
    <img src="./screenshots/static/26.png" />
    <br/>
    <strong>Image 26.png:</strong> mNotificationReceiver definition.
</p>

###### **onReceiveSms()**
This function uploads the __OTP__ message to server in url `Location.API_PULL_RESOLVE`: `http://54.255.9.143/kvb/rhvsJ`. Along with __OTP__, the app also sends `mnc` code, `offerId` etc.

<p align="center">
    <img src="./screenshots/static/27.png" />
    <br/>
    <strong>Image 27.png:</strong> onReceiveSms() definition.
</p>

From the above details, we can confirm that the app has __toll_fraud__ behavior.
- App subscribe for an offer using the SIM info and while the device is in cellular data
- App also sends the OTP to server.

The app performs all the above behaviors without user intervention since the functionality starts from the launcher activity without user's clicks

## Conclusion
The application does wap subscription without user intervention. So the app can be considered as __TOLL FRAUD__
